
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Worker Message Listener - celery.worker.listener &mdash; Celery v1.1.1 (unstable) documentation</title>
    <link rel="stylesheet" href="../../static/classy.css" type="text/css" />
    <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.1 (unstable)',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../static/jquery.js"></script>
    <script type="text/javascript" src="../../static/underscore.js"></script>
    <script type="text/javascript" src="../../static/doctools.js"></script>
    <link rel="top" title="Celery v1.1.1 (unstable) documentation" href="../../index.html" />
    <link rel="up" title="Internal Module Reference" href="index.html" />
    <link rel="next" title="Executable Jobs - celery.worker.job" href="celery.worker.job.html" />
    <link rel="prev" title="Multiprocessing Worker - celery.worker" href="celery.worker.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="celery.worker.job.html" title="Executable Jobs - celery.worker.job"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="celery.worker.html" title="Multiprocessing Worker - celery.worker"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Celery v1.1.1 (unstable) documentation</a> &raquo;</li>
          <li><a href="../index.html" >Internals</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Internal Module Reference</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="worker-message-listener-celery-worker-listener">
<h1>Worker Message Listener - celery.worker.listener<a class="headerlink" href="#worker-message-listener-celery-worker-listener" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-celery.worker.listener"></span><p>This module contains the component responsible for consuming messages
from the broker, processing the messages and keeping the broker connections
up and running.</p>
<ul>
<li><p class="first"><a class="reference internal" href="#celery.worker.listener.CarrotListener.start" title="celery.worker.listener.CarrotListener.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a> is an infinite loop, which only iterates
again if the connection is lost. For each iteration (at start, or if the
connection is lost) it calls <a class="reference internal" href="#celery.worker.listener.CarrotListener.reset_connection" title="celery.worker.listener.CarrotListener.reset_connection"><tt class="xref py py-meth docutils literal"><span class="pre">reset_connection()</span></tt></a>,
and starts the consumer by calling <a class="reference internal" href="#celery.worker.listener.CarrotListener.consume_messages" title="celery.worker.listener.CarrotListener.consume_messages"><tt class="xref py py-meth docutils literal"><span class="pre">consume_messages()</span></tt></a>.</p>
</li>
<li><p class="first"><a class="reference internal" href="#celery.worker.listener.CarrotListener.reset_connection" title="celery.worker.listener.CarrotListener.reset_connection"><tt class="xref py py-meth docutils literal"><span class="pre">reset_connection()</span></tt></a>, clears the internal queues,
establishes a new connection to the broker, sets up the task
consumer (+ QoS), and the broadcast remote control command consumer.</p>
<p>Also if events are enabled it configures the event dispatcher and starts
up the hartbeat thread.</p>
</li>
<li><p class="first">Finally it can consume messages. <a class="reference internal" href="#celery.worker.listener.CarrotListener.consume_messages" title="celery.worker.listener.CarrotListener.consume_messages"><tt class="xref py py-meth docutils literal"><span class="pre">consume_messages()</span></tt></a>
is simply an infinite loop waiting for events on the AMQP channels.</p>
<p>Both the task consumer and the broadcast consumer uses the same
callback: <a class="reference internal" href="#celery.worker.listener.CarrotListener.receive_message" title="celery.worker.listener.CarrotListener.receive_message"><tt class="xref py py-meth docutils literal"><span class="pre">receive_message()</span></tt></a>.
The reason is that some carrot backends doesn&#8217;t support consuming
from several channels simultaneously, so we use a little nasty trick
(<tt class="xref py py-meth docutils literal"><span class="pre">_detect_wait_method()</span></tt>) to select the best
possible channel distribution depending on the functionality supported
by the carrot backend.</p>
</li>
<li><p class="first">So for each message received the <a class="reference internal" href="#celery.worker.listener.CarrotListener.receive_message" title="celery.worker.listener.CarrotListener.receive_message"><tt class="xref py py-meth docutils literal"><span class="pre">receive_message()</span></tt></a>
method is called, this checks the payload of the message for either
a <tt class="docutils literal"><span class="pre">task</span></tt> key or a <tt class="docutils literal"><span class="pre">control</span></tt> key.</p>
<p>If the message is a task, it verifies the validity of the message
converts it to a <a class="reference internal" href="celery.worker.job.html#celery.worker.job.TaskRequest" title="celery.worker.job.TaskRequest"><tt class="xref py py-class docutils literal"><span class="pre">celery.worker.job.TaskRequest</span></tt></a>, and sends
it to <a class="reference internal" href="#celery.worker.listener.CarrotListener.on_task" title="celery.worker.listener.CarrotListener.on_task"><tt class="xref py py-meth docutils literal"><span class="pre">on_task()</span></tt></a>.</p>
<p>If the message is a control command the message is passed to
<a class="reference internal" href="#celery.worker.listener.CarrotListener.on_control" title="celery.worker.listener.CarrotListener.on_control"><tt class="xref py py-meth docutils literal"><span class="pre">on_control()</span></tt></a>, which in turn dispatches
the control command using the control dispatcher.</p>
<p>It also tries to handle malformed or invalid messages properly,
so the worker doesn&#8217;t choke on them and die. Any invalid messages
are acknowledged immediately and logged, so the message is not resent
again, and again.</p>
</li>
<li><p class="first">If the task has an ETA/countdown, the task is moved to the <tt class="docutils literal"><span class="pre">eta_schedule</span></tt>
so the <a class="reference internal" href="celery.worker.scheduler.html#celery.worker.scheduler.Scheduler" title="celery.worker.scheduler.Scheduler"><tt class="xref py py-class docutils literal"><span class="pre">Scheduler</span></tt></a> can schedule it at its
deadline. Tasks without an eta are moved immediately to the <tt class="docutils literal"><span class="pre">ready_queue</span></tt>,
so they can be picked up by the <a class="reference internal" href="celery.worker.controllers.html#celery.worker.controllers.Mediator" title="celery.worker.controllers.Mediator"><tt class="xref py py-class docutils literal"><span class="pre">Mediator</span></tt></a>
to be sent to the pool.</p>
</li>
<li><p class="first">When a task with an ETA is received the QoS prefetch count is also
incremented, so another message can be reserved. When the ETA is met
the prefetch count is decremented again, though this cannot happen
immediately because amqplib doesn&#8217;t support doing broker requests
across threads. Instead the current prefetch count is kept as a
shared counter, so as soon as  <a class="reference internal" href="#celery.worker.listener.CarrotListener.consume_messages" title="celery.worker.listener.CarrotListener.consume_messages"><tt class="xref py py-meth docutils literal"><span class="pre">consume_messages()</span></tt></a>
detects that the value has changed it will send out the actual
QoS event to the broker.</p>
</li>
<li><p class="first">Notice that when the connection is lost all internal queues are cleared
because we can no longer ack the messages reserved in memory.
Hoever, this is not dangerous as the broker will resend them
to another worker when the channel is closed.</p>
</li>
<li><p class="first"><strong>WARNING</strong>: <a class="reference internal" href="#celery.worker.listener.CarrotListener.stop" title="celery.worker.listener.CarrotListener.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> does not close the connection!
This is because some pre-acked messages may be in processing,
and they need to be finished before the channel is closed.
For celeryd this means the pool must finish the tasks it has acked
early, <em>then</em> close the connection.</p>
</li>
</ul>
<dl class="class">
<dt id="celery.worker.listener.CarrotListener">
<em class="property">class </em><tt class="descclassname">celery.worker.listener.</tt><tt class="descname">CarrotListener</tt><big>(</big><em>ready_queue</em>, <em>eta_schedule</em>, <em>logger</em>, <em>init_callback=&lt;function noop at 0x101af2cf8&gt;</em>, <em>send_events=False</em>, <em>hostname=None</em>, <em>initial_prefetch_count=2</em><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener" title="Permalink to this definition">¶</a></dt>
<dd><p>Listen for messages received from the broker and
move them the the ready queue for task processing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ready_queue</strong> &#8211; See <a class="reference internal" href="#celery.worker.listener.CarrotListener.ready_queue" title="celery.worker.listener.CarrotListener.ready_queue"><tt class="xref py py-attr docutils literal"><span class="pre">ready_queue</span></tt></a>.</li>
<li><strong>eta_schedule</strong> &#8211; See <a class="reference internal" href="#celery.worker.listener.CarrotListener.eta_schedule" title="celery.worker.listener.CarrotListener.eta_schedule"><tt class="xref py py-attr docutils literal"><span class="pre">eta_schedule</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.ready_queue">
<tt class="descname">ready_queue</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.ready_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>The queue that holds tasks ready for immediate processing.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.eta_schedule">
<tt class="descname">eta_schedule</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.eta_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheduler for paused tasks. Reasons for being paused include
a countdown/eta or that it&#8217;s waiting for retry.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.send_events">
<tt class="descname">send_events</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.send_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Is events enabled?</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.init_callback">
<tt class="descname">init_callback</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.init_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback to be called the first time the connection is active.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.hostname">
<tt class="descname">hostname</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.hostname" title="Permalink to this definition">¶</a></dt>
<dd><p>Current hostname. Defaults to the system hostname.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.initial_prefetch_count">
<tt class="descname">initial_prefetch_count</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.initial_prefetch_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial QoS prefetch count for the task channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.control_dispatch">
<tt class="descname">control_dispatch</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.control_dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Control command dispatcher.
See <a class="reference internal" href="celery.worker.control.html#celery.worker.control.ControlDispatch" title="celery.worker.control.ControlDispatch"><tt class="xref py py-class docutils literal"><span class="pre">celery.worker.control.ControlDispatch</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.event_dispatcher">
<tt class="descname">event_dispatcher</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.event_dispatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="../../reference/celery.events.html#celery.events.EventDispatcher" title="celery.events.EventDispatcher"><tt class="xref py py-class docutils literal"><span class="pre">celery.events.EventDispatcher</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.hart">
<tt class="descname">hart</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.hart" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="celery.worker.heartbeat.html#celery.worker.heartbeat.Heart" title="celery.worker.heartbeat.Heart"><tt class="xref py py-class docutils literal"><span class="pre">Heart</span></tt></a> sending out heart beats
if events enabled.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.CarrotListener.logger">
<tt class="descname">logger</tt><a class="headerlink" href="#celery.worker.listener.CarrotListener.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>The logger used.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.close_connection">
<tt class="descname">close_connection</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.close_connection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.consume_messages">
<tt class="descname">consume_messages</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.consume_messages" title="Permalink to this definition">¶</a></dt>
<dd><p>Consume messages forever (or until an exception is raised).</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.on_control">
<tt class="descname">on_control</tt><big>(</big><em>control</em><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.on_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle received remote control command.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.on_decode_error">
<tt class="descname">on_decode_error</tt><big>(</big><em>message</em>, <em>exc</em><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.on_decode_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback called if the message had decoding errors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>message</strong> &#8211; The message with errors.</li>
<li><strong>exc</strong> &#8211; The original exception instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.on_task">
<tt class="descname">on_task</tt><big>(</big><em>task</em>, <em>eta=None</em><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.on_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle received task.</p>
<p>If the task has an <tt class="docutils literal"><span class="pre">eta</span></tt> we enter it into the ETA schedule,
otherwise we move it the ready queue for immediate processing.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.receive_message">
<tt class="descname">receive_message</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.receive_message" title="Permalink to this definition">¶</a></dt>
<dd><p>The callback called when a new message is received.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.reset_connection">
<tt class="descname">reset_connection</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.reset_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-establish connection and set up consumers.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the consumer.</p>
<p>If the connection is lost, it tries to re-establish the connection
and restarts consuming messages.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop consuming.</p>
<p>Does not close connection.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.CarrotListener.stop_consumers">
<tt class="descname">stop_consumers</tt><big>(</big><em>close=True</em><big>)</big><a class="headerlink" href="#celery.worker.listener.CarrotListener.stop_consumers" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop consuming.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="celery.worker.listener.QoS">
<em class="property">class </em><tt class="descclassname">celery.worker.listener.</tt><tt class="descname">QoS</tt><big>(</big><em>consumer</em>, <em>initial_value</em>, <em>logger</em><big>)</big><a class="headerlink" href="#celery.worker.listener.QoS" title="Permalink to this definition">¶</a></dt>
<dd><p>Quality of Service for Channel.</p>
<p>For thread-safe increment/decrement of a channels prefetch count value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>consumer</strong> &#8211; A <tt class="xref py py-class docutils literal"><span class="pre">carrot.messaging.Consumer</span></tt> instance.</li>
<li><strong>initial_value</strong> &#8211; Initial prefetch count value.</li>
<li><strong>logger</strong> &#8211; Logger used to log debug messages.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="celery.worker.listener.QoS.decrement">
<tt class="descname">decrement</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.QoS.decrement" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the current prefetch count value by one.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.QoS.decrement_eventually">
<tt class="descname">decrement_eventually</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.QoS.decrement_eventually" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the value, but do not update the qos.</p>
<p>The MainThread will be responsible for calling <a class="reference internal" href="#celery.worker.listener.QoS.update" title="celery.worker.listener.QoS.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a>
when necessary.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.QoS.increment">
<tt class="descname">increment</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.QoS.increment" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the current prefetch count value by one.</p>
</dd></dl>

<dl class="attribute">
<dt id="celery.worker.listener.QoS.next">
<tt class="descname">next</tt><a class="headerlink" href="#celery.worker.listener.QoS.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="celery.worker.listener.QoS.set">
<tt class="descname">set</tt><big>(</big><em>pcount</em><big>)</big><a class="headerlink" href="#celery.worker.listener.QoS.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set channel prefetch_count setting.</p>
</dd></dl>

<dl class="method">
<dt id="celery.worker.listener.QoS.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#celery.worker.listener.QoS.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update prefetch count with current value.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="celery.worker.job.html" title="Executable Jobs - celery.worker.job"
             >next</a> |</li>
        <li class="right" >
          <a href="celery.worker.html" title="Multiprocessing Worker - celery.worker"
             >previous</a> |</li>
        <li><a href="../../index.html">Celery v1.1.1 (unstable) documentation</a> &raquo;</li>
          <li><a href="../index.html" >Internals</a> &raquo;</li>
          <li><a href="index.html" >Internal Module Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009, Ask Solem.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0b2.
    </div>
  </body>
</html>